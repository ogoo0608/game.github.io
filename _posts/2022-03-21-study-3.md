---
layout: single
title: "[Study] 수업 정리 (3/21 ~ 3/25)"
toc: true
toc_sticky: true
toc_label: "study"
categories:
    - Study
---

<br>

## 자료구조 (3월 21일)

<br>

- Algorithm

    - 문제를 해결하기 위한 단계적인 절차와 단계를 pseudo code를 사용하여 기술하며, 입력, 출력, 명확성, 유한성, 실제성의 5대 조건을 만족
    - 알고리즘에 대한 연산의 빈도수를 차수 (degree)로 표현하며, 연산 차수가 가장 높은 것을 O-표시법으로 사용 // O(1), O(mlog n), O(n), ...
    - 연산의 빈도에 대한 차수가 가장 낮은 것을 오메가-표시법으로 사용하며, O-표시법과 오메가-표시법의 교차집합이 되는 h-표 표시법을 최적 알고리즘으로 사용

- 배열
    - 연속적인 기억장치에 하나의 블록으로 저장
    - 연속적으로 배치된 기억장소의 위치이며, Index와 값(value)을 mapping
    - 2개 이상의 변수가 공통된 성질을 가지고, 하나의 변수와 첨자를 사용
    - row-oriented, column-oriented 배열로 구분

<br>

## 물리와 프로그래밍 (3월 21일)

<br>

함수 인수 개수 

- 0개 (ex_ np.random.random())
- 1개 (ex_ int(2.5))
- 콤마로 분리된 2개 이상의 인수 (ex_ pow(2.5, 3))
- 가변 개수의 인수 (ex_ max(2,3), max(2,3,4))

<br>

함수가 반환하는 결과 값의 개수

- 0개 (ex_ print('hello')는 IPython 콘솔에 텍스트 출력하는 동작 수행, ex_ plt.savefig 그림(plot)을 파일에 저장하는 동작)
- 1개 (ex_ numpy.sqrt(2))
- 여러 개의 반환된 값들 이용 가능 (5.3절 참고)
- Keyword arguments: 𝑓(𝑥,𝑦)=𝑥 𝑒^(−𝑦);𝑓(1, 2)  "or" 𝑓(𝑦=2, 𝑥=1) (5.1절 참고)

<br> 

### Ch.2 Structure and Control

<br>

- 2.1 객체(Objects)와 객체 메서드(Methods)
- 2.2 리스트(Lists), 튜플(Tuples), 배열(Arrays)
- 2.3 문자열(Strings)
- 2.4 루프(Loops): for loop, while loop
- 2.5 배열 연산(Array operations)
- 2.6 스크립트(Scripts)
- 2.7 조건적 동작: 분기(Contingent behavior: Branching): if
- 2.8 중첩(Nesting)

<br>

객체 (object) : (데이터, 함수)의 조합
- 파이썬에서 모든 것은 객체
- assignment statement (배정문) : 이름을 객체에 연계 &rarr; 변수 (variable) 

<br>

## 물리와 프로그래밍 (3월 23일)

<br>

### List 

<br>

```py
List, Tuple, Arrays

>>> a = [1,2,3,['a','b','c']]
>>> a
>>> a[0]
>>> a[1]
```

- 리스트에 요소 추가 (append)
- 위치 반환 (index)
- 리스트에 요소 삽입 (insert)

<br>

index &rarr; 위치 (첫 번째 위치 : 0)

컴퓨터에서 변수는 메모리다 !

<br>

```py
# 리스트에 요소 추가하자 append

a = [1,2,3]
a.append(4)
append(4) ==> X # append 라는 함수의 목적이 되는 변수 이름을 지정해줘야 함
a
a.append([5,6])
a # Out) [1,2,3,4,[5,6]]
a.append(5,6) # append 는 오직 한 개의 인수만을 갖는다 ..
```

```py
a = [1,4,3,2]
a
a.sort() # List 를 크기 순으로 정렬 해주는 함수 sort() 
a # Out) [1,2,3,4]
a = ['a', 'c', 'b']
a.sort()
a # Out) ['a', 'b', 'c']
```

```py
a = [1, 2, 3]
# List의 위치 변환
a.index(1) # 1이라는 원소의 인덱스 (위치) 가 몇 번째인지 알려줌 Out) 0
a.index(2) # Out) 1
a.index(3) # Out) 2
```

```py
# List에 요소를 삽입. append와 구별해야 함
a.insert(0,4) # 0번째 위치에다가 4라는 요소를 넣으라는 의미
a # Oui) [4,1,2,3]
```

**insert 와 append 의 차이 알아둘 것**

```py
insert(i,j)
i 위치에 j를 삽입하라는 의미
```

```py
# 요소 끄집어 내기 -> pop() : 마지막 원소를 끄집어 내서 보여줌. 빼내는 원소만큼 리스트가 줄어들음
a = [1,2,3]
a.pop() # 마지막 원소를 끄집어 냄 (위치 지정 안 했을시)
a # Out) 3
a.pop(0) 
a # Out) 1
```

<br>

### Tuple

<br>

**List 와 Tuple 의 차이**

전자는 값을 수정할 수 있지만, 후자는 값을 변경할 수 없음 .. ([] vs ()의 차이 역시 있음)

근데 왜 Tuple을 쓰는가? &rarr; List에 비해 더 적은 메모리를 필요로 하고, 속도가 빠르다는 장점 때문에 .........

<br>

### Dictionary 

<br>

Key와 Value를 한 쌍으로 갖는 자료형

```py
dic = {'name':'pey', 'phone':'01012345678', 'birth':'0608'}
```

List, Tuple에서 indexing 하는 방법과 비교
- 순차적으로 내용을 찾는 것이 아니라 key 를 사용해서 바로 접근

<br>

## C++ (3월 21일)

<br>

### Ch6. functions

reference 변수는 메모리 영역을 공유한다. 

call by reference = & 

**Reference variable itself does not reserve mem space.** (무조건 상기할 것)

- C++ provides a special type of variable, called a reference variable
- can be used as a function parameter to reference the original variable. 
- A reference variable is an alias for another variable
- Any changes made through the reference variable are actually performed on the original variable. 
- To declare a reference variable, place the ampersand (&) in front of the name. 

<br>

**매개변수 개수, 매개변수의 Data type, 함수의 이름** (무조건 상기할 것)

<br>

```cpp
#include <iostream>
using namespace std;
void sub(int i, int& r); // 이때 &의 역할은 pass by reference
void swap_PassByValue(int x, int y);
void swap_PassByRef(int& x, int& y);
// void swap_PassByPtr(int* xp, int* yp);
int main() {
	/*int a = 1, b = 2;

	cout << "address of a : " << &a << endl;
	cout << "address of b : " << &b << endl;

	sub(a, b);*/

	int i, j;
	cout << "i의 값 : "; 
	cin >> i;
	cout << "j의 값 : ";
	cin >> j;
	cout << "address of i : " << &i << endl;
	cout << "address of j : " << &j << endl;
	swap_PassByValue(i, j); // 변경 X
	cout << "i : " << i << " j : " << j << endl;
	swap_PassByRef(i, j); // 변경 O
	cout << "i : " << i << " j : " << j << endl;
	return 0;
}
void sub(int i, int& r) {
	cout << "address of i : " << &i << endl;
	cout << "address of r : " << &r << endl;
	i = 100;
	r = 200;

}

void swap_PassByValue(int x, int y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}

void swap_PassByRef(int& x, int& y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}
```

_실행결과_

```
i의 값 : -5
j의 값 : 70
address of i : 0000005A453EF7B4
address of j : 0000005A453EF7D4
address of x : 0000005A453EF790
address of y : 0000005A453EF798
i : -5 j : 70
address of x : 0000005A453EF7B4
address of y : 0000005A453EF7D4
i : 70 j : -5
```

_빌드 - 구성관리자 - 플랫폼을 win32 로 변경 후 실행결과_

```
i의 값 : -5
j의 값 : 70
address of i : 012FFBE8
address of j : 012FFBDC
address of x : 012FFB04
address of y : 012FFB08
i : -5 j : 70
address of x : 012FFBE8
address of y : 012FFBDC
i : 70 j : -5
```


<br>

homework _ 6.33 ! p.287 (이번주 일요일)

Ch 7 : Array (내일까지 ㅋㅋㅋㅋ 아..)
Ch 11 : pointer, array&pointer &rarr; 중요

<br>

C++ does not check array's boundary. So, accessing array elements using subscripts beyond the boundary does not cause syntax errors..

element 접근 시 상수가 아니라 변수가 와도 된다~

<br>

## C++ (3월 22일) 

<br>

### Pass-by-Value?

<br>

`A = B; ` 

안 되는 이유 &rarr; A는 배열의 첫 번째 주소인 상수이기 때문..

<br>

```cpp
int A[3] = {5,8,-7};
int B[3] = {-5, -8, 70};

double d = 58.7;
double D[3] = {7.7, 8.8, 99.99}
32 bits !!
```
```
메모리 컨텐츠는 4개의 비트 단위로 만들어짐.
```

<br>

```cpp
#include <iostream>

using namespace std;

int main() {
	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };
	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;
	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;


	return 0;
}
```

실행 결과_
```
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
```

물론 실행 결과의 플랫폼은 win32 기준이다.

<br>

```cpp
#include <iostream>

using namespace std;

int main() {
	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };
	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;
	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;
	cout << "A : " << A << endl; // 배열 A의 0번째 요소의 현재 메모리 컨텐츠 시작 주소가 나온다 ,,
	cout << "&A[0] : " << &A[0] << endl;
	cout << "&A[1] : " << &A[1] << endl;


	return 0;
}
```

실행 결과_
```
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
A : 004FF8D4
&A[0] : 004FF8D4
&A[1] : 004FF8D8
```

&A[0] &rarr; &A[1] 의 차이는 4 !!!

<br>

```cpp
#include <iostream>

using namespace std;

int main() {
	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };
	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;
	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;
	cout << "A : " << A << endl; // 배열 A의 0번째 요소의 현재 메모리 컨텐츠 시작 주소가 나온다 ,,
	cout << "&A[0] : " << &A[0] << endl;
	cout << "&A[1] : " << &A[1] << endl;
	cout << "C : " << C << endl; 
	cout << "&C[0] : " << &C[0] << endl;
	cout << "&C[1] : " << &C[1] << endl;



	return 0;
}
```

실행 결과_
```
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
A : 008FFB0C
&A[0] : 008FFB0C
&A[1] : 008FFB10
C : 008FFAD8
&C[0] : 008FFAD8
&C[1] : 008FFAE0
```

<br>

```cpp
#include <iostream>

using namespace std;

int main() {
	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };
	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;
	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;
	cout << "A : " << A << endl; // 배열 A의 0번째 요소의 현재 메모리 컨텐츠 시작 주소가 나온다 ,,
	cout << "&A[0] : " << &A[0] << endl;
	cout << "&A[1] : " << &A[1] << endl;
	cout << "C : " << C << endl; 
	cout << "&C[0] : " << &C[0] << endl;
	cout << "&C[1] : " << &C[1] << endl;
	cout << "D : " << D << endl;
	cout << "&D[0] : " << &D[0] << endl;
	cout << "&D[1] : " << &D[1] << endl;

	return 0;
}
```

실행 결과_
```
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
A : 008FF71C
&A[0] : 008FF71C
&A[1] : 008FF720
C : 008FF6E8
&C[0] : 008FF6E8
&C[1] : 008FF6F0
D : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[0] : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[1] : ello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
```

### **이렇게 결과가 나온 이유**

<br>

**char ptr 배열의 경우** cout를 만나면 

해당하는 배열의 주소에서 시작하는 문자열이 왔구나 !! 

하고 생각하고 문자열을 출력하게 됨 ,,,

solution __ 형 변환을 하자 ....

<br>

```cpp
#include <iostream>

using namespace std;

int main() {
	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };
	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;
	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;
	cout << "A : " << A << endl; // 배열 A의 0번째 요소의 현재 메모리 컨텐츠 시작 주소가 나온다 ,,
	cout << "&A[0] : " << &A[0] << endl;
	cout << "&A[1] : " << &A[1] << endl;
	cout << "C : " << C << endl; 
	cout << "&C[0] : " << &C[0] << endl;
	cout << "&C[1] : " << &C[1] << endl;
	cout << "D : " << D << endl;
	cout << "&D[0] : " << &D[0] << endl;
	cout << "&D[1] : " << &D[1] << endl;
	cout << "(void *)E : " << (void *)E << endl;
	cout << "(void *)&E[0] : " << (void*)&E[0] << endl;
	cout << "(void *)&E[1] : " << (void*)&E[1] << endl;

	return 0;
}
```

실행 결과_
```
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
A : 0056FA7C
&A[0] : 0056FA7C
&A[1] : 0056FA80
C : 0056FA48
&C[0] : 0056FA48
&C[1] : 0056FA50
D : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[0] : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[1] : ello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
(void *)E : 0056FA28
(void *)&E[0] : 0056FA28
(void *)&E[1] : 0056FA29
```

<br>

```cpp
char E[] = "Hello";
위의 E 는 6byte 잡아먹음 ,, 
```

<br>


### 중요 (농담아님)

<br>


```cpp
#include <iostream>

using namespace std;

int funcMin(int A[], int size);
void copyArr(int To[], int From[], int size);
void printArr(int A[], int size);

int main() {

	int A[3] = { 10,20,30 };
	int B[3] = { -7, -8, 99 };
	double C[3] = { 5.7, 8.8, 2.1 };

	cout << "A 배열의 최소값 : " << funcMin(A, 3) << endl;
	copyArr(A, B, 3);
	printArr(A, 3);

	char D[] = { 'H', 'e', 'l', 'l', 'o'};
	char E[] = { 'H', 'e', 'l', 'l', 'o', '\0' };

	cout << "sizeof(int) : " << sizeof(int) << endl;
	cout << "sizeof(double) : " << sizeof(double) << endl;
	cout << "sizeof(char) : " << sizeof(char) << endl;

	cout << "sizeof(A) : " << sizeof(A) << endl;
	cout << "sizeof(B) : " << sizeof(B) << endl;
	cout << "sizeof(C) : " << sizeof(C) << endl;
	cout << "sizeof(D) : " << sizeof(D) << endl;
	cout << "sizeof(E) : " << sizeof(E) << endl;

	cout << "A : " << A << endl; 
	/* 배열 A의 0번째 요소의 현재 메모리 컨텐츠 시작 주소가 나온다 ,,,, */
	cout << "&A[0] : " << &A[0] << endl;
	cout << "&A[1] : " << &A[1] << endl;

	cout << "C : " << C << endl; 
	cout << "&C[0] : " << &C[0] << endl;
	cout << "&C[1] : " << &C[1] << endl;

	cout << "D : " << D << endl;
	cout << "&D[0] : " << &D[0] << endl;
	cout << "&D[1] : " << &D[1] << endl;

	cout << "(void *)E : " << (void *)E << endl;
	cout << "(void *)&E[0] : " << (void*)&E[0] << endl;
	cout << "(void *)&E[1] : " << (void*)&E[1] << endl;

	return 0;
}

int funcMin(int K[], int size) {
	cout << "K in funcMin() : " << K << endl;
	int min = K[0];
	for (int i = 0; i < size; i++) {
		if (min > K[i]) {
			min = K[i];

			}

		}
	return min;
}

void copyArr(int To[], int From[], int size) {
	for (int i = 0; i < size; i++) {
		To[i] = From[i];
	}
}

void printArr(int A[], int size) {
	for (int i = 0; i < size; i++) {
		cout << A[i] << " ";

	}

	cout << endl;

}
```

실행 결과_ 
```
K in funcMin() : 00B5FDD0
A 배열의 최소값 : 10
-7 -8 99
sizeof(int) : 4
sizeof(double) : 8
sizeof(char) : 1
sizeof(A) : 12
sizeof(B) : 12
sizeof(C) : 24
sizeof(D) : 5
sizeof(E) : 6
A : 00B5FDD0
&A[0] : 00B5FDD0
&A[1] : 00B5FDD4
C : 00B5FD9C
&C[0] : 00B5FD9C
&C[1] : 00B5FDA4
D : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[0] : Hello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
&D[1] : ello儆儆儆儆儆勁儆儆?@슇솛솛!@蠱儆儆
(void *)E : 00B5FD7C
(void *)&E[0] : 00B5FD7C
(void *)&E[1] : 00B5FD7D
```

<br>

7.1 ~ 7.2 checkpoint 실습

<br>

### Chapter 11 (Pointers, relationship ... )

<br>

&11.5 까지 읽고 와야 됨 ,,,,, 

checkpoint &rarr; 반드시 강의를 듣고 실습할 것

포인터도 배열이기 때문에 메모리를 가져야 함 ...

<br>

### What is Pointer ?

<br>

```
Pointer variables, simply called pointers, are designed to hold memory addresses as their values. 

Normally, a variable contains a specific value, e.g., an integer, a floating-point value, and a character. 

However, a pointer contains the memory address of a variable that in turn contains a specific value. 
```

<br>

Memory 뿐만 아니라 Pointer 역시 파악할 수 있어야 함

<br>

## 웹프로그래밍 (3월 24일)

<br>

### HTML 기본태그

<br>

제목, 문단, 형식, 목록, 하이퍼링크 등 HTML의 기본 태그들의 종류와 사용법을 배워보자.

콘텐츠 구조 설계 가능하게끔 공부하자

<br>

```
<html> 태그는 문서의 시작과 종료를 나타냄 !

<head> 태그는 HTML 문서에 필요한 여러 정보를 표시하는 메타 컨테이너 !
- <title> 태그를 통해 브라우저 상단 타이틀 정의
- JavaScript 및 CSS 코드를 직접 작성하거나 외부 파일을 import 혹은 url link.
- <meta> 태그를 통해 모바일 화면설정과 SEO (Search Engine Optimization) 정보 제공
- 모든 컨텐츠는 <body> </body> 사이에 위치해야 함

Block 태그

- 한 줄에 여러 요소가 위치하지 못하는 태그를 말한다.

ex_ <div>, <h1>, <h6>, ...

Inline 태그

- 나란히 배치 가능한 태그 ..

ex_ <span>, <a>, <img>, ...

나중에는 CSS로 서로 전환 가능 ..
```

여러 공백을 넣으려면 `&nbsp;` 

그다지 권장되는 방법은 아님 .....

이 수업 개꿀인게 태그 배워서 마크다운 파일에 그대로 적용할 수 있음 ,,,

`<strong> & <em> , <b> & <i> 태그의 결과가 같지만, 그 태그가 가지는 의미가 다르다..`


<br>

**목록 태그 중요함 !** &rarr; List 

`두 종류가 있다. <ul> <ol>`

Unordered List : 순서없이 모양으로 목록을 만듦 ...... 

Ordered List : 번호를 매기는 순서가 있는 목록을 만듦 ......

<br>

### 하이퍼링크

웹의 대표적인 특징, `<a>` (Anchor) 태그를 사용해 만들 수 있음 ..

href 속성을 사용해 이동할 컨텐츠의 주소를 기술하면 됨 ...

```html
<a href="이동할 컨텐츠" target="브라우저 윈도우 옵션">링크 텍스트</a>
```

href 에 들어가는 이동할 컨텐츠의 위치 &rarr; 상대경로 혹은 절대경로로 표현 가능

물론 내 컴퓨터 위치가 아니라 .. html 을 서비스하고 있는 웹서버 컴퓨터에서 콘텐츠 간의 위치를 말하는 것 ..

- 절대경로는 고유한 경로로 root (/) 에서부터 시작되는 위치로 지정하는 방법
	- ex_ /home/contents/img/1.jpg

- 상대경로는 HTML 문서를 기준으로 경로를 지정하는 방법. 권장 방법 !!
	- img/1.jpg

사실 절대경로를 쓰면 잘못될 일도 없고 좋음. 그러나 경우에 따라서 이 경로가 매우 길어짐 .. 즉 불편할수도 있음.

그러니까 콘텐츠의 위치가 가깝다면 그냥 상대경로를 쓰면 됨.

상황에 맞게 쓰면 되는거임 !!

- Local 컴퓨터의 절대경로를 쓰면 안 됨. 당연한 소리

<br>

target 속성 값

- _blank &rarr; 새로운 웹 브라우저 창으로 오픈
- _self &rarr; default (현재 웹 브라우저 창으로 오픈)
- _parent &rarr; 부모 웹 브라우저 창으로 오픈
- _top &rarr; 웹 브라우저 전체 영역에 오픈 / 근데 이건 요즘 안 씀

<br>

### 책갈피 구현

- `<a>` 태그를 이용해 같은 문서 내에서 특정 위치로 이동하는 책갈피 기능 구현 가능
- `<p>` 태그의 name 속성이나 id 속성을 이용해 문서 내 이동위치를 지정하고 하이퍼 링크에 `href=#name(id)` 과 같이 이동할 위치를 지정함.

```html
메뉴
<a href="#ml">5.HTML이란 무엇인가?</a>
......
<p id="ml"></p>
<h3>5.HTML이란 무엇인가?</h3>
```

href 태그의 ID 앞에는 반드시 # ..

ID 값은 문서 내에서 유인을 해야됨.. 즉 중복 X

그니까 뭐다? 찾기가 쉽다 .. 유일한 위치 .. !!

<br>

실습 과제 할 때 윈도우 사이즈 반드시 줄일 것 .. ^^

<br>

### 이미지 링크

- 텍스트가 아닌 이미지를 링크로 사용할 수도 있음 .. 이 경우 `<a><img></a>` 형식 .. 

```html
<a href="http://www.gachon.ac.kr">
	<img src="gachonlogo.jpg" alt="gachon_logo">
</a>
```

<br>

### 예제 2-1) 제목과 문단 태그 활용

```html
<!doctype html>
<html> 
    <head>
        <title> Example : 2-1 </title>
    </head>
    <body>
        <h1> example 2-1 </h1>
        <h2> html example </h2>
        
        <p> hello world </p>
        <p> hello
             world
        </p>
        <p> hello <br> world </p>
        <pre>
            hello world
            hello
                world
        </pre>
        <pre>
            <h2> hello
                     world
            </h2>
        </pre>
    </body>
</html>
```

<br>

### 예제 2-2) 텍스트 관련 태그 활용

```html
<!doctype html>
<html> 
    <head>
        <title>Example: 2-2</title>
    </head>
    <body>
        <b>bold text</b><br>
        <strong>strong text</strong><br>
        <i>italic text</i><br>
        <em>emphasized text</em><br>
        <mark>mark text</mark><br>
        <small>small text</small><br>
        <del>deleted text</del><br>
        <ins>inserted text</ins><br>
        This is <sup>superscript text</sup><br>
        This is <sub>subscript text</sub>
        
    </body>
</html>
```

<br>

### 예제 2-3) 목록 만들기

```html
<!doctype html>
<html> 
    <head>
        <title>Example: 2-3</title>
    </head>
    <body>
        <h2>Unordered List</h2>
        <ul type="square">
        <li>Coffee</li>
        <li>Tea</li>
        <li>Milk</li>
        </ul>  

        <h2>Ordered List</h2>
        <ol type="A">
        <li>Coffee</li>
        <li>Tea</li>
        <li>Milk</li>
        </ol> 
    </body>
</html>
```

<br>

### 예제 2-4) 하이퍼링크 활용

```html
<!doctype html>
<html> 
    <head>
        <title>Example: 2-4</title>
    </head>
    <body>
        <a href="http://www.gachon.ac.kr" target="_blank">Gachon</a> <br>
    </body>
</html>
```

<br>

### 예제 2-5) 책갈피 구현

```html
<!doctype html>
<html> 
    <head>
        <title>Example: 2-5</title>
    </head>
    <body>
        <h1>Menu</h1>
        <a href="#index1">Coffee</a><br>
        <a href="#index2">Cake</a><br>
        <a href="#index3">Juice</a><br>

        
        <h2 id="index1">Menu01::Coffee</h2>
        <ul>
            <li>Americano</li>
            <li>Cappuccino</li>
            <li>Cafe latte</li>
        </ul>
        
        <h2 id="index2">Menu02::Cake</h2>
        <ul>
            <li>Carrot cake</li>
            <li>black tea cake</li>
            <li>Strawberry shortcake</li>
        </ul>
        
        <h2 id="index3">Menu03::Juice</h2>
        <ul>
            <li>orange</li>
            <li>grape</li>
            <li>watermelon</li>
        </ul>

    </body>
</html>
```