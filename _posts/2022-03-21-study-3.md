---
layout: single
title: "ìˆ˜ì—… ì •ë¦¬ (3/21 ~ )"
toc: true
toc_sticky: true
toc_label: "study"
categories:
    - Study
---

<br>

## ìë£Œêµ¬ì¡° (3ì›” 21ì¼)

<br>

- Algorithm

    - ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë‹¨ê³„ì ì¸ ì ˆì°¨ì™€ ë‹¨ê³„ë¥¼ pseudo codeë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ìˆ í•˜ë©°, ì…ë ¥, ì¶œë ¥, ëª…í™•ì„±, ìœ í•œì„±, ì‹¤ì œì„±ì˜ 5ëŒ€ ì¡°ê±´ì„ ë§Œì¡±
    - ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•œ ì—°ì‚°ì˜ ë¹ˆë„ìˆ˜ë¥¼ ì°¨ìˆ˜ (degree)ë¡œ í‘œí˜„í•˜ë©°, ì—°ì‚° ì°¨ìˆ˜ê°€ ê°€ì¥ ë†’ì€ ê²ƒì„ O-í‘œì‹œë²•ìœ¼ë¡œ ì‚¬ìš© // O(1), O(mlog n), O(n), ...
    - ì—°ì‚°ì˜ ë¹ˆë„ì— ëŒ€í•œ ì°¨ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ê²ƒì„ ì˜¤ë©”ê°€-í‘œì‹œë²•ìœ¼ë¡œ ì‚¬ìš©í•˜ë©°, O-í‘œì‹œë²•ê³¼ ì˜¤ë©”ê°€-í‘œì‹œë²•ì˜ êµì°¨ì§‘í•©ì´ ë˜ëŠ” h-í‘œ í‘œì‹œë²•ì„ ìµœì  ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì‚¬ìš©

- ë°°ì—´
    - ì—°ì†ì ì¸ ê¸°ì–µì¥ì¹˜ì— í•˜ë‚˜ì˜ ë¸”ë¡ìœ¼ë¡œ ì €ì¥
    - ì—°ì†ì ìœ¼ë¡œ ë°°ì¹˜ëœ ê¸°ì–µì¥ì†Œì˜ ìœ„ì¹˜ì´ë©°, Indexì™€ ê°’(value)ì„ mapping
    - 2ê°œ ì´ìƒì˜ ë³€ìˆ˜ê°€ ê³µí†µëœ ì„±ì§ˆì„ ê°€ì§€ê³ , í•˜ë‚˜ì˜ ë³€ìˆ˜ì™€ ì²¨ìë¥¼ ì‚¬ìš©
    - row-oriented, column-oriented ë°°ì—´ë¡œ êµ¬ë¶„

<br>

## ë¬¼ë¦¬ì™€ í”„ë¡œê·¸ë˜ë° (3ì›” 21ì¼)

<br>

í•¨ìˆ˜ ì¸ìˆ˜ ê°œìˆ˜ 

- 0ê°œ (ex_ np.random.random())
- 1ê°œ (ex_ int(2.5))
- ì½¤ë§ˆë¡œ ë¶„ë¦¬ëœ 2ê°œ ì´ìƒì˜ ì¸ìˆ˜ (ex_ pow(2.5, 3))
- ê°€ë³€ ê°œìˆ˜ì˜ ì¸ìˆ˜ (ex_ max(2,3), max(2,3,4))

<br>

í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ê²°ê³¼ ê°’ì˜ ê°œìˆ˜

- 0ê°œ (ex_ print('hello')ëŠ” IPython ì½˜ì†”ì— í…ìŠ¤íŠ¸ ì¶œë ¥í•˜ëŠ” ë™ì‘ ìˆ˜í–‰, ex_ plt.savefig ê·¸ë¦¼(plot)ì„ íŒŒì¼ì— ì €ì¥í•˜ëŠ” ë™ì‘)
- 1ê°œ (ex_ numpy.sqrt(2))
- ì—¬ëŸ¬ ê°œì˜ ë°˜í™˜ëœ ê°’ë“¤ ì´ìš© ê°€ëŠ¥ (5.3ì ˆ ì°¸ê³ )
- Keyword arguments: ğ‘“(ğ‘¥,ğ‘¦)=ğ‘¥ ğ‘’^(âˆ’ğ‘¦);ğ‘“(1, 2)  "or" ğ‘“(ğ‘¦=2, ğ‘¥=1) (5.1ì ˆ ì°¸ê³ )

<br> 

### Ch.2 Structure and Control

<br>

- 2.1 ê°ì²´(Objects)ì™€ ê°ì²´ ë©”ì„œë“œ(Methods)
- 2.2 ë¦¬ìŠ¤íŠ¸(Lists), íŠœí”Œ(Tuples), ë°°ì—´(Arrays)
- 2.3 ë¬¸ìì—´(Strings)
- 2.4 ë£¨í”„(Loops): for loop, while loop
- 2.5 ë°°ì—´ ì—°ì‚°(Array operations)
- 2.6 ìŠ¤í¬ë¦½íŠ¸(Scripts)
- 2.7 ì¡°ê±´ì  ë™ì‘: ë¶„ê¸°(Contingent behavior: Branching): if
- 2.8 ì¤‘ì²©(Nesting)

<br>

ê°ì²´ (object) : (ë°ì´í„°, í•¨ìˆ˜)ì˜ ì¡°í•©
- íŒŒì´ì¬ì—ì„œ ëª¨ë“  ê²ƒì€ ê°ì²´
- assignment statement (ë°°ì •ë¬¸) : ì´ë¦„ì„ ê°ì²´ì— ì—°ê³„ &rarr; ë³€ìˆ˜ (variable) 

<br>

## C++ (3ì›” 21ì¼)

<br>

### Ch6. functions

reference ë³€ìˆ˜ëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ì„ ê³µìœ í•œë‹¤. 

call by reference = & 

**Reference variable itself does not reserve mem space.** (ë¬´ì¡°ê±´ ìƒê¸°í•  ê²ƒ)

- C++ provides a special type of variable, called a reference variable
- can be used as a function parameter to reference the original variable. 
- A reference variable is an alias for another variable
- Any changes made through the reference variable are actually performed on the original variable. 
- To declare a reference variable, place the ampersand (&) in front of the name. 

<br>

**ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜, ë§¤ê°œë³€ìˆ˜ì˜ Data type, í•¨ìˆ˜ì˜ ì´ë¦„** (ë¬´ì¡°ê±´ ìƒê¸°í•  ê²ƒ)

<br>

```cpp
#include <iostream>
using namespace std;
void sub(int i, int& r); // ì´ë•Œ &ì˜ ì—­í• ì€ pass by reference
void swap_PassByValue(int x, int y);
void swap_PassByRef(int& x, int& y);
// void swap_PassByPtr(int* xp, int* yp);
int main() {
	/*int a = 1, b = 2;

	cout << "address of a : " << &a << endl;
	cout << "address of b : " << &b << endl;

	sub(a, b);*/

	int i, j;
	cout << "iì˜ ê°’ : "; 
	cin >> i;
	cout << "jì˜ ê°’ : ";
	cin >> j;
	cout << "address of i : " << &i << endl;
	cout << "address of j : " << &j << endl;
	swap_PassByValue(i, j); // ë³€ê²½ X
	cout << "i : " << i << " j : " << j << endl;
	swap_PassByRef(i, j); // ë³€ê²½ O
	cout << "i : " << i << " j : " << j << endl;
	return 0;
}
void sub(int i, int& r) {
	cout << "address of i : " << &i << endl;
	cout << "address of r : " << &r << endl;
	i = 100;
	r = 200;

}

void swap_PassByValue(int x, int y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}

void swap_PassByRef(int& x, int& y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}
```

_ì‹¤í–‰ê²°ê³¼_

```
iì˜ ê°’ : -5
jì˜ ê°’ : 70
address of i : 0000005A453EF7B4
address of j : 0000005A453EF7D4
address of x : 0000005A453EF790
address of y : 0000005A453EF798
i : -5 j : 70
address of x : 0000005A453EF7B4
address of y : 0000005A453EF7D4
i : 70 j : -5
```

_ë¹Œë“œ - êµ¬ì„±ê´€ë¦¬ì - í”Œë«í¼ì„ win32 ë¡œ ë³€ê²½ í›„ ì‹¤í–‰ê²°ê³¼_

```
iì˜ ê°’ : -5
jì˜ ê°’ : 70
address of i : 012FFBE8
address of j : 012FFBDC
address of x : 012FFB04
address of y : 012FFB08
i : -5 j : 70
address of x : 012FFBE8
address of y : 012FFBDC
i : 70 j : -5
```


<br>

homework _ 6.33 ! p.287 (ì´ë²ˆì£¼ ì¼ìš”ì¼)

Ch 7 : Array (ë‚´ì¼ê¹Œì§€ ã…‹ã…‹ã…‹ã…‹ ì•„..)
Ch 11 : pointer, array&pointer &rarr; ì¤‘ìš”

<br>

C++ does not check array's boundary. So, accessing array elements using subscripts beyond the boundary does not cause syntax errors..

element ì ‘ê·¼ ì‹œ ìƒìˆ˜ê°€ ì•„ë‹ˆë¼ ë³€ìˆ˜ê°€ ì™€ë„ ëœë‹¤~

