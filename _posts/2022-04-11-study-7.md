---
layout: single
title: "[Major] 수업 정리 (4/11 ~ )"
toc: true
toc_sticky: true
toc_label: "study"
categories:
    - Study
---

<br>

## 물리와프로그래밍 (4월 11일)

<br>

### Broadcast (흩뿌리다) &larr; 확장의 의미를 가짐

<br>

**브로드캐스팅 조건**

- 두 넘파이 배열 중 최소한 하나의 배열의 어떤 축이라도 관계없이 차원이 1이라면 가능하다
- 두 넘파이 배열의 차원에 대해서 축의 길이가 동일하면 가능하다

<br>

Ex_
```py
import numpy as np
a = np.array([1,2,3])
b = np.array([1,2,3,4])
print(a+b)

>>>
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-4-85111a3ab660> in <module>
----> 1 print(a+b)

ValueError: operands could not be broadcast together with shapes (3,) (4,) 
```

&uarr; 축의 길이가 동일하지 않음

<br>

```py
a = np.array([[1,2,3],[4,5,6]])
b = 2
c = a*b
c
>>>
array([[ 2,  4,  6],
       [ 8, 10, 12]])
```
```
a는 벡터, b는 스칼라인데 c로 새로운 벡터(배열)로 확장(broadcast) 가능하다
```

<br>

```py
np.sum(a,0) # a라는 배열에서 0번째 축의 원소들을 다 더하라는 의미
```

<br>

```py
a = np.vstack((np.arange(20), np.arange(100,120)))
a
>>>
array([[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
         13,  14,  15,  16,  17,  18,  19],
       [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
        113, 114, 115, 116, 117, 118, 119]])
```
```py
b = np.sum(a,0) # 위의 행과 아래행의 원소들을 더해서 1행의 새로운 배열을 생성
b
>>> 
array([100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
       126, 128, 130, 132, 134, 136, 138])
```
```py
c = np.sum(a,1)
c
>>>
array([ 190, 2190])
```

<br>

```py
a = np.array([[3,0,-1,1],[2,-1,-2,4],[1,7,0,4]])
a.min()
>>> -2
```

<br>

### Scripts &rarr; text file (series of commands)

<br>

**Jupyter &rarr; Interpreter**

**Spyder &rarr; Scripts**

<br>

### Debugging &rarr; 에러 or 경고 메시지 잘 읽기

<br>

- 코드를 주의해서 읽어본다
- 코드를 천천히 개발한다. 간단한 작업을 수행하는 각각의 단계가 정확히 의도된 작업을 수행하는지 확인한다.
- 간단한 데이터를 사용하여 코드를 확인한다
- 변수들을 조사하라 &rarr; a라는 변수를 사용 중, 중간중간에 a에 어떤 값이 있는지 출력해본다. (이런 기능이 있는 개발환경이 있다)
- 진단을 위한 명령들을 삽입한다. 오류 발생이 의심되는 곳 앞에 그 시점에서 특정 변수들이 갖고 있는 값들을 출력해본다.
- 코드를 작성하면서 사전 대책을 세운다
- 주변 친구들에게 도움을 받는다 Ex_ **Stackoverflow.com**
- **break points**를 이용한다 (어떤 지점에서 멈추는 것)

<br>

## C++ (4월 11일)

<br>

Ex_11_02

```cpp
#include <iostream>
#include <cctype>
using namespace std;

int main()
{
  // Prompt the user to enter array size
  cout << "Enter array size: ";
  int arraySize;
  cin >> arraySize;

  char* numbers = new char[arraySize];
  int size = 0;

  for (int i = 0; i < arraySize; i++)
  {
        // Read and store character in an array if it is not a vowel
        cout << "Enter a character: ";
        char ch;
        cin >> ch;

        bool isVowel = false;

          if (tolower(ch) == 'a' || tolower(ch) == 'e' || tolower(ch) == 'i' || tolower(ch) == 'o' || tolower(ch) == 'u')
          {
            isVowel = true;
          }

        if (!isVowel)
        {
          *(numbers + size) = ch;
          size++;
        }
  }

  if(size == 0)
  {
      cout << "There are no consonants in the array!" << endl;
      return 0;
  }

  for (int i = 0; i < size; i++)
    cout << *(numbers + i) << " ";

  return 0;
}


```

<br>


스택의 메모리는 아래로 내려갈 수록 증가함

먼저 선언 &rarr; 맨 밑으로 이동

<br>

### Ch09

<br>

```cpp
int A[5] = {999,0,0,0,0,0};
char B[5] = "MEMO";

cout << A << endl; --> 0번째 요소의 주소값을 출력한다.

*(A+0) 

>>>
```
```
cout 은 특이하게 char * (포인터) 가 오면 문자열을 출력한다
int, del, 같은 포인터는 주소를 출력하는데 ..
cout << (void *) B << endl; 라고 해야 주소가 출력됨 !! 
```

<br>

```cpp
size&(A)
20 (4bytes * 5)
size&(B)
5 (1bytes * 5)
```

<br>

리버스 &rarr; func() 에서 함 main() 이 아니라

그러나 해지와 사용은 main() 에서

다이나믹 알로케이션은 함수와 함수를 넘나들 수 있는 특성이 있음


<br>

## C++ (4월 12일)

<br>

member variable = member field

<br>

컴파일러는 함수를 3가지로 함수를 구분 : 함수를 구분하기 위한 구성요소를 시그너처(signature)라 한다. 

Signature 구성 하는 것 3가지

- 이름
- Parameter 개수
- Parameter data type

<br>

Return 값이 없을 때는 Void 를 써야 하는데 

교수님이 보여준 함수는 객체가 생성될 때 (메모리 확보) 

member variable을 초기화 하기 위한 특수 목적을 갖고 있기 때문에 void 와 반환 (return) 둘 다 없어도 됨..

<br>

Class 는 기본적으로 기능을 제공하는 것임.

라이브러리를 파는 것 = Class 를 만들어서 파는 것 (Class는 일종의 서버 역할)

UML 넘어감

<br>

function = method

Class is a Type

<br>

**Constructor 계수와 deconstructor 계수가 같은지 반드시 확인해야 한다.**

### ExCircle

<br>

```cpp
#include <iostream>
using namespace std;
class Circle {
public:
	double radius; // Member Variable
	double getArea(); // Member Function
	Circle(); // Constructor without argument
	Circle(double r); // Constructor with argument
	~Circle(); // deconstructor
};
double Circle::getArea() {
	return 3.14 * radius * radius;
}
Circle::Circle() {
	cout << "Constructor without arguement" << endl;
	radius = 1;
} 
Circle::Circle(double r) {
	cout << "Constructor with arguement" << endl;
	radius = r;
}
Circle::~Circle() {

	cout << "deconstructor without arguement" << endl;
}
int main() {
	cout << "sizeof(Circle) : " << sizeof(Circle) << endl;
	Circle c1;
	cout << "sizeof(c1) : " << sizeof(c1) << endl;
	cout << "c1.getArea() : " << c1.getArea() << endl;
	Circle c2(10);
	cout << "c2.getArea() : " << c2.getArea() << endl;
	return 0;
}
```

```
sizeof(Circle) : 8
Constructor without arguement
sizeof(c1) : 8
c1.getArea() : 3.14
Constructor with arguement
c2.getArea() : 314
deconstructor without arguement
deconstructor without arguement
```

<br>

