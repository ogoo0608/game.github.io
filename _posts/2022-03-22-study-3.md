---
layout: single
title: "수업 정리 (3/21 ~ )"
toc: true
toc_sticky: true
toc_label: "study"
categories:
    - Study
---

<br>

## 자료구조 (3월 21일)

<br>

- Algorithm

    - 문제를 해결하기 위한 단계적인 절차와 단계를 pseudo code를 사용하여 기술하며, 입력, 출력, 명확성, 유한성, 실제성의 5대 조건을 만족
    - 알고리즘에 대한 연산의 빈도수를 차수 (degree)로 표현하며, 연산 차수가 가장 높은 것을 O-표시법으로 사용 // O(1), O(mlog n), O(n), ...
    - 연산의 빈도에 대한 차수가 가장 낮은 것을 오메가-표시법으로 사용하며, O-표시법과 오메가-표시법의 교차집합이 되는 h-표 표시법을 최적 알고리즘으로 사용

- 배열
    - 연속적인 기억장치에 하나의 블록으로 저장
    - 연속적으로 배치된 기억장소의 위치이며, Index와 값(value)을 mapping
    - 2개 이상의 변수가 공통된 성질을 가지고, 하나의 변수와 첨자를 사용
    - row-oriented, column-oriented 배열로 구분

<br>

## 물리와 프로그래밍 (3월 21일)

<br>

함수 인수 개수 

- 0개 (ex_ np.random.random())
- 1개 (ex_ int(2.5))
- 콤마로 분리된 2개 이상의 인수 (ex_ pow(2.5, 3))
- 가변 개수의 인수 (ex_ max(2,3), max(2,3,4))

<br>

함수가 반환하는 결과 값의 개수

- 0개 (ex_ print('hello')는 IPython 콘솔에 텍스트 출력하는 동작 수행, ex_ plt.savefig 그림(plot)을 파일에 저장하는 동작)
- 1개 (ex_ numpy.sqrt(2))
- 여러 개의 반환된 값들 이용 가능 (5.3절 참고)
- Keyword arguments: 𝑓(𝑥,𝑦)=𝑥 𝑒^(−𝑦);𝑓(1, 2)  "or" 𝑓(𝑦=2, 𝑥=1) (5.1절 참고)

<br> 

### Ch.2 Structure and Control

<br>

- 2.1 객체(Objects)와 객체 메서드(Methods)
- 2.2 리스트(Lists), 튜플(Tuples), 배열(Arrays)
- 2.3 문자열(Strings)
- 2.4 루프(Loops): for loop, while loop
- 2.5 배열 연산(Array operations)
- 2.6 스크립트(Scripts)
- 2.7 조건적 동작: 분기(Contingent behavior: Branching): if
- 2.8 중첩(Nesting)

<br>

객체 (object) : (데이터, 함수)의 조합
- 파이썬에서 모든 것은 객체
- assignment statement (배정문) : 이름을 객체에 연계 &rarr; 변수 (variable) 

<br>

## C++ (3월 21일)

<br>

### Ch6. functions

reference 변수는 메모리 영역을 공유한다. 

call by reference = & 

**Reference variable itself does not reserve mem space.** (무조건 상기할 것)

- C++ provides a special type of variable, called a reference variable
- can be used as a function parameter to reference the original variable. 
- A reference variable is an alias for another variable
- Any changes made through the reference variable are actually performed on the original variable. 
- To declare a reference variable, place the ampersand (&) in front of the name. 

<br>

**매개변수 개수, 매개변수의 Data type, 함수의 이름** (무조건 상기할 것)

<br>

```cpp
#include <iostream>
using namespace std;
void sub(int i, int& r); // 이때 &의 역할은 pass by reference
void swap_PassByValue(int x, int y);
void swap_PassByRef(int& x, int& y);
// void swap_PassByPtr(int* xp, int* yp);
int main() {
	/*int a = 1, b = 2;

	cout << "address of a : " << &a << endl;
	cout << "address of b : " << &b << endl;

	sub(a, b);*/

	int i, j;
	cout << "i의 값 : "; 
	cin >> i;
	cout << "j의 값 : ";
	cin >> j;
	cout << "address of i : " << &i << endl;
	cout << "address of j : " << &j << endl;
	swap_PassByValue(i, j); // 변경 X
	cout << "i : " << i << " j : " << j << endl;
	swap_PassByRef(i, j); // 변경 O
	cout << "i : " << i << " j : " << j << endl;
	return 0;
}
void sub(int i, int& r) {
	cout << "address of i : " << &i << endl;
	cout << "address of r : " << &r << endl;
	i = 100;
	r = 200;

}

void swap_PassByValue(int x, int y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}

void swap_PassByRef(int& x, int& y) {
	cout << "address of x : " << &x << endl;
	cout << "address of y : " << &y << endl;
	int temp = x;
	x = y;
	y = temp;
}
```

_실행결과_

```
i의 값 : -5
j의 값 : 70
address of i : 0000005A453EF7B4
address of j : 0000005A453EF7D4
address of x : 0000005A453EF790
address of y : 0000005A453EF798
i : -5 j : 70
address of x : 0000005A453EF7B4
address of y : 0000005A453EF7D4
i : 70 j : -5
```

_빌드 - 구성관리자 - 플랫폼을 win32 로 변경 후 실행결과_

```
i의 값 : -5
j의 값 : 70
address of i : 012FFBE8
address of j : 012FFBDC
address of x : 012FFB04
address of y : 012FFB08
i : -5 j : 70
address of x : 012FFBE8
address of y : 012FFBDC
i : 70 j : -5
```


<br>

homework _ 6.33 ! p.287 (이번주 일요일)

Ch 7 : Array (내일까지 ㅋㅋㅋㅋ 아..)
Ch 11 : pointer, array&pointer &rarr; 중요

<br>

C++ does not check array's boundary. So, accessing array elements using subscripts beyond the boundary does not cause syntax errors..

element 접근 시 상수가 아니라 변수가 와도 된다~

